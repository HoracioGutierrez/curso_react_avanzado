LINKS

https://marketplace.visualstudio.com/items?itemName=patbenatar.advanced-new-file
https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets
https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?utm_source=chrome-ntp-icon
https://github.com/goncy/firestore-beers-store

https://www.meteor.com/
https://www.npmjs.com/package/validator
https://www.npmjs.com/package/bcrypt


/src
    |_api/
        |_store.js
        |_reducer.js
        |_actions.js
    |_ui/
        |_layout/
            |_App.js
            |_Header.js
            |_Footer.js
            |_Main.js
        |_componentes/
            |_Usuarios.js
            |_ListadoUsuarios.js
            |_FormularioUsuarios.js
        |_paginas/


Los componentes siempre son funciones con retorno en mayuscula

function App(){ return }

let App = function(){ return }

let App = () => { return  }


class App extends Component {

    render(){
        return
    }
}



REDUX y REACT-REDUX : Redux es la libreria que controla el patron de dise√±o pub-sub y react-redux es la implementacion de redux en una app de react


IMPLEMENTACION DE REDUX : Necesitamos crear un store,un reducer y actions


IMPLEMENTACION DE REACT-REDUX : Necesitamos un Provider (HOC) que nos sirve para envolver a todo un arbol de React en redux y a partir de ahi podemos conectar los componentes de manera individual


CONEXION DE COMPONENTE CON REDUX : 

connect(a,b)(Componente) : La funcion connect nos sirve para envolver un componente de React y pasarle props adicionales (Ademas de los que ya le podrian estar llegando). Toma dos parametros y ambos dos son funciones

a : nos sirve para leer propiedades del store. Recibe un UNICO parametro y es una copia del store.

b : nos sirve para despachar acciones. Recibe un UNICO parametro y es una copia de la funcion dispatch. 







REDUX SAGA : La diferencia con redux thunk es que esta libreria usa funciones generadoras.

GENERATOR FUNCTION : Es aquella que en primer instancia nos retorna un objeto que implementa la interfaz de Iterator y ademas pueden ser pausadas en cualquier momento y volver a resumirse con el mismo contexto


function foo(){
    return {
        next(){
            return {value:Any,done:Boolean}
        }
    }
}


let result = foo()
let primer_next = result.next()

console.log(primer_next.value,primer_next.done)


function* miFuncionGeneradora(){
    yield "hola"
}

let res = miFuncionGeneradora()
res.next() {value:"Hola",done:false}




SYMBOL = Es un tipo de dato nuevo desde ES6 que nos sirve para crear nombres de propiedades en objetos las cuales nos asguran que van a ser siempre UNICAS


let a = {}
a.prop = 1

let sym = Symbol()
let s_1 = Symbol("horacio")
let s_2 = Symbol("horacio")

s_1 == s_2 //False


let obj = {}
obj[s_1] = true

for(prop in obj){
    console.log(prop) //No nos da nada
}


Object.getOwnPropertySymbols(obj)
Reflect.ownKeys(obj)



ITERABLE = Deberia presentar una propiedad en alguna parte de su prototipo descripta con Symbol.iterator y esta deberia ser una funcion que nos devuelve un objeto el cual implementa una funcion next.
Cada vez que ejecutemos next nos tiene que retornar un objeto con dos propiedades : value y done

let obj = {
    iterar : function(){

        let contador = 0

        return {
            next : function(){

                return {
                    value : contador++,
                    done : false
                }

            }
        }
    }
}




GENERATORS

function* iterar(){
    let contador = 0
    while(true){
        yield contador++
    }
}


iterar()





SAGA ENRUTADOR (ROOT) = Es una funcion generadora que se encargaria de activar el resto de todos los saga

SAGA WATCHER = Es una funcion generadora que se encargaria de estar esperando a que nosotros despachemos un tipo de accion

SAGA WORKERS = Es una funcion generadora que se encargaria de hacer los side effects